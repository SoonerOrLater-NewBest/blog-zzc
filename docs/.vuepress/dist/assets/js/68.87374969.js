(window.webpackJsonp=window.webpackJsonp||[]).push([[68],{665:function(e,t,_){"use strict";_.r(t);var v=_(45),o=Object(v.a)({},(function(){var e=this,t=e.$createElement,_=e._self._c||t;return _("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[_("h1",{attrs:{id:"登录认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#登录认证"}},[e._v("#")]),e._v(" "),_("Label",{attrs:{level:3}}),e._v("登录认证")],1),e._v(" "),_("blockquote",[_("p",[e._v("登录认证几乎是任何一个系统的标配，web 系统、APP、PC 客户端等，好多都需要注册、登录、授权认证。")])]),e._v(" "),_("h2",{attrs:{id:"登录场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#登录场景"}},[e._v("#")]),e._v(" 登录场景")]),e._v(" "),_("ol",[_("li",[e._v("首次使用，需要通过邮箱或手机号注册；")]),e._v(" "),_("li",[e._v("注册完成后，需要提供用户名和密码完成登录；")]),e._v(" "),_("li",[e._v("下次再使用，通常不会再次输入用户名和密码即可直接进入系统并使用其功能（除非连续长时间未使用）；")])]),e._v(" "),_("h2",{attrs:{id:"常用的认证方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常用的认证方式"}},[e._v("#")]),e._v(" 常用的认证方式")]),e._v(" "),_("h3",{attrs:{id:"oauth-认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oauth-认证"}},[e._v("#")]),e._v(" OAuth 认证")]),e._v(" "),_("p",[e._v("OAuth 认证比较常见的就是微信登录、微博登录、qq 登录等，简单来说就是利用这些比较权威的网站或应用开放的 API 来实现用户登录，用户可以不用在你的网站或应用上注册账号，直接用已有的微信、微博、qq 等账号登录。")]),e._v(" "),_("p",[e._v("这样一来，即省了用户注册的时间，又简化了你的系统的账号体系。从而既可以提高用户注册率可以节省开发时间，同时，安全性也有了保障。")]),e._v(" "),_("p",[e._v("维基百科对它的解释摘要如下：")]),e._v(" "),_("blockquote",[_("p",[e._v("OAuth 允许用户提供一个令牌，而不是用户名和密码来访问他们存放在特定服务提供者的数据。每一个令牌授权一个特定的网站（例如，视频编辑网站)在特定的时段（例如，接下来的 2 小时内）内访问特定的资源（例如仅仅是某一相册中的视频）。这样，OAuth 让用户可以授权第三方网站访问他们存储在另外服务提供者的某些特定信息，而非所有内容。")])]),e._v(" "),_("p",[e._v("假设我们开发了一个电商平台，并集成了微信登录，以这个场景为例，说一下 OAuth 的工作原理。")]),e._v(" "),_("p",[e._v("讲之前需要了解其中涉及到的几个角色：")]),e._v(" "),_("p",[e._v("用户：即使用我们平台的用户\n用户终端：即最终用户使用的 APP 端或 web 端\n应用服务器端：即我们的服务器端\n授权服务器端：这里就是微信处理授权请求的服务器\n好的，接下来开始在我们的电商平台 web 端实现微信登录功能。微信网页授权是授权码模式（authorization code）的 OAuth 授权模式。")]),e._v(" "),_("p",[e._v("我们电商平台的用户过来登录，常用场景是点击“微信登录”按钮；\n接下来，用户终端将用户引导到微信授权页面；\n用户同意授权，应用服务器重定向到之前设置好的 redirect_uri （应用服务器所在的地址），并附带上授权码（code）;\n应用服务器用上一步获取的 code 向微信授权服务器发送请求，获取 access_token，也就是上面说的令牌；\n之后应用服务器用上一步获取的 access_token 去请求微信授权服务器获取用户的基本信息，例如头像、昵称等；")]),e._v(" "),_("h3",{attrs:{id:"cookie-session-认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie-session-认证"}},[e._v("#")]),e._v(" Cookie-Session 认证")]),e._v(" "),_("p",[e._v("早期互联网以 web 为主，客户端是浏览器，所以 Cookie-Session 方式最那时候最常用的方式，直到现在，一些 web 网站依然用这种方式做认证。")]),e._v(" "),_("p",[_("strong",[e._v("认证过程大致如下")]),e._v("：")]),e._v(" "),_("ol",[_("li",[e._v("用户输入用户名、密码或者用短信验证码方式登录系统；")]),e._v(" "),_("li",[e._v("服务端验证后，创建一个 Session 信息，并且将 SessionID 存到 cookie，发送回浏览器；")]),e._v(" "),_("li",[e._v("下次客户端再发起请求，自动带上 cookie 信息，服务端通过 cookie 获取 Session 信息进行校验；")])]),e._v(" "),_("p",[_("strong",[e._v("弊端")])]),e._v(" "),_("ul",[_("li",[e._v("只能在 web 场景下使用，如果是 APP 中，不能使用 cookie 的情况下就不能用了；")]),e._v(" "),_("li",[e._v("即使能在 web 场景下使用，也要考虑跨域问题，因为 cookie 不能跨域；")]),e._v(" "),_("li",[e._v("cookie 存在 CSRF（跨站请求伪造）的风险；")]),e._v(" "),_("li",[e._v("如果是分布式服务，需要考虑 Session 同步问题；")])]),e._v(" "),_("h3",{attrs:{id:"cookie-session-改造版"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#cookie-session-改造版"}},[e._v("#")]),e._v(" Cookie-Session 改造版")]),e._v(" "),_("p",[e._v("由于传统的 Cookie-Session 认证存在诸多问题，可以把上面的方案改造一下。改动的地方如下：")]),e._v(" "),_("ul",[_("li",[e._v("不用 cookie 做客户端存储，改用其他方式，web 下使用 local storage，APP 中使用客户端数据库，这样就实现了跨域，并且避免了 CSRF ;")]),e._v(" "),_("li",[e._v("服务端也不存 Session 了，把 Session 信息拿出来存到 Redis 等内存数据库中，这样即提高了速度，又避免了 Session 同步问题；")])]),e._v(" "),_("p",[_("strong",[e._v("经过改造之后变成了如下的认证过程")]),e._v("：")]),e._v(" "),_("ol",[_("li",[e._v("用户输入用户名、密码或者用短信验证码方式登录系统；")]),e._v(" "),_("li",[e._v("服务端经过验证，将认证信息构造好的数据结构存储到 Redis 中，并将 key 值返回给客户端；")]),e._v(" "),_("li",[e._v("客户端拿到返回的 key，存储到 local storage 或本地数据库；")]),e._v(" "),_("li",[e._v("下次客户端再次请求，把 key 值附加到 header 或者 请求体中；")]),e._v(" "),_("li",[e._v("服务端根据获取的 key，到 Redis 中获取认证信息；")])]),e._v(" "),_("h3",{attrs:{id:"基于-jwt-的-token-认证"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基于-jwt-的-token-认证"}},[e._v("#")]),e._v(" 基于 JWT 的 Token 认证")]),e._v(" "),_("p",[_("a",{attrs:{href:"https://blog.csdn.net/xunileida/article/details/82961714",target:"_blank",rel:"noopener noreferrer"}},[e._v("JWT 原理"),_("OutboundLink")],1)]),e._v(" "),_("p",[e._v("上面的方案虽然经过了改版，但还是需要客户端和服务器端维持一个状态信息，比如用 cookie 换 session ,或者用 key 换 Redis 的 value 信息，基于 JWT 的 Token 认证方案可以省去这个过程。")]),e._v(" "),_("p",[e._v("JSON Web Token（JWT）是一个非常轻巧的规范。这个规范允许我们使用 JWT 在用户和服务器之间传递安全可靠的信息。")]),e._v(" "),_("p",[_("strong",[e._v("认证过程")])]),e._v(" "),_("ol",[_("li",[e._v("依然是用户登录系统；")]),e._v(" "),_("li",[e._v('服务端验证，将认证信息通过指定的算法（例如 HS256）进行加密，例如对用户名和用户所属角色进行加密，加密私钥是保存在服务器端的，将加密后的结果发送给客户端，加密的字符串格式为三个"." 分隔的字符串 Token，分别对应头部、载荷与签名，头部和载荷都可以通过 base64 解码出来，签名部分不可以；')]),e._v(" "),_("li",[e._v("客户端拿到返回的 Token，存储到 local storage 或本地数据库；")]),e._v(" "),_("li",[e._v("下次客户端再次发起请求，将 Token 附加到 header 中；")]),e._v(" "),_("li",[e._v("服务端获取 header 中的 Token ，通过相同的算法对 Token 中的用户名和所属角色进行相同的加密验证，如果验证结果相同，则说明这个请求是正常的，没有被篡改。这个过程可以完全不涉及到查询 Redis 或其他存储；")])]),e._v(" "),_("p",[_("strong",[e._v("优点")])]),e._v(" "),_("ul",[_("li",[e._v("使用 json 作为数据传输，有广泛的通用型，并且体积小，便于传输；")]),e._v(" "),_("li",[e._v("不需要在服务器端保存相关信息；")]),e._v(" "),_("li",[e._v("jwt 载荷部分可以存储业务相关的信息（非敏感的），例如用户信息、角色等；")])]),e._v(" "),_("h2",{attrs:{id:"总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[e._v("#")]),e._v(" 总结")]),e._v(" "),_("p",[e._v("综上所述，JWT 可以作为首选的认证方案。当然，具体的情况具体分析，还要看是不是适合真实的应用场景。除了上述的这些，涉及到信息安全的，建议全部采用 https 方式部署，采用 https 方式，信息很难被嗅探破解，对应用的安全性很重要。")]),e._v(" "),_("p",[e._v("参考信息：")]),e._v(" "),_("p",[e._v("OAuth: http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html")]),e._v(" "),_("p",[e._v("JWT：https://jwt.io/introduction/ http://blog.leapoahead.com/2015/09/06/understanding-jwt/")]),e._v(" "),_("p",[e._v("JWT Java 库: https://github.com/jwtk/jjwt")])])}),[],!1,null,null,null);t.default=o.exports}}]);