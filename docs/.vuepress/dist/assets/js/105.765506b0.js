(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{703:function(t,e,a){"use strict";a.r(e);var s=a(45),r=Object(s.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"vite"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[t._v("#")]),t._v(" "),a("Label",{attrs:{level:1}}),t._v("Vite")],1),t._v(" "),a("p",[a("a",{attrs:{href:"https://juejin.cn/post/6931618997251080200?content_source_url=https%3A%2F%2Fgithub.com%2Fvue3%2Fvue3-News",target:"_blank",rel:"noopener noreferrer"}},[t._v("123"),a("OutboundLink")],1)]),t._v(" "),a("h3",{attrs:{id:"天下苦-webpack-久矣"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#天下苦-webpack-久矣"}},[t._v("#")]),t._v(" 天下苦 webpack 久矣")]),t._v(" "),a("p",[t._v("在前端这块混，肯定不能没有听说过 webpack，现代的大型前端应用一般都是用这玩意构建的，但是随着项目的增大，大家发现了 webpack 几个「难言之隐」")]),t._v(" "),a("ul",[a("li",[t._v("随着项目大小增长，项目冷启动时间指数增长")]),t._v(" "),a("li",[t._v("热更新时间也会随着项目大小增大而增长")])]),t._v(" "),a("p",[t._v("所以才有了我们常戏称的：npm run dev ，然后去上个厕所，喝杯咖啡，回来可能还没跑完，极大的影响了开发效率。虽然 webpack 提供了很多方法去做构建优化，在日益庞大的前端项目中仍然不太够用，能不能有一种方式一劳永逸的解决这个问题呢？答案就是 Vite ！")]),t._v(" "),a("h3",{attrs:{id:"vite-横空出世"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite-横空出世"}},[t._v("#")]),t._v(" Vite 横空出世")]),t._v(" "),a("p",[t._v("vite 是如何解决这个世纪难题的呢，答案是  native ES modules。在浏览器没有原生模块化支持的时代，我们往往需要通过 webpack 等构建工具将整个项目打包成一个 js 文件，方便浏览器进行调用。但是随着浏览器厂商的不断努力，现代浏览器基本已经全部支持了 import/ export 语法，")]),t._v(" "),a("h3",{attrs:{id:"为什么-webpack-这么慢"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么-webpack-这么慢"}},[t._v("#")]),t._v(" 为什么 Webpack 这么慢")]),t._v(" "),a("p",[t._v("在之前的浏览器中没有模块化的设计，所以期望把所有源代码编译进一个 js 文件中提供给浏览器使用，所以在开发中当我们运行启动命令的时候，webpack 总是需要从入口文件去索引整个项目的文件，编译成一个或多个单独的 js 文件，即使采用了代码拆分，也需要一次生成所有路由下的编译后文件（这也是为什么代码拆分对开发模式性能没有帮助）。这也导致了服务启动时间随着项目复杂度而指数增长")]),t._v(" "),a("h2",{attrs:{id:"vite-是如何解决问题的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#vite-是如何解决问题的"}},[t._v("#")]),t._v(" Vite 是如何解决问题的")]),t._v(" "),a("p",[t._v("vite 是如何通过使用 native ES modules 优化服务启动时间的呢，使用 Vite 启动开发服务器的时候并不需要提前编译文件（其实是有一个类似过程的，下文详述），而是在浏览器请求对应 URL 的时候，再提供对应的文件，这就实现了在使用了路由懒加载的项目中，仅提供对应路由下的模块的编译文件，而没有索引全部代码的这一过程，项目启动时间始终为常量级。并不会随着项目复杂度变高而一直增长，我们来看看具体是怎么做的")]),t._v(" "),a("h3",{attrs:{id:"依赖预构建"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#依赖预构建"}},[t._v("#")]),t._v(" 依赖预构建")]),t._v(" "),a("p",[t._v("对 native ES modules 了解的同学可能会想到，它是不支持如下的裸模块导入的，那咋办")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("import")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" someMethod "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("from")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token string"}},[t._v("'my-dep'")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[t._v("经过 Vite 编译后的 src/main.tsx 文件,可以看到之前的 from 'react' 被重写为了 from \"/node_modules/.vite/react.js?v=432aac16\"")]),t._v(" "),a("p",[t._v("看起来 Vite 会将预构建的依赖缓存到 node_modules/.vite 路径下，可以看到文件名后跟着一串随机字符串，很容易就可以想到是用来控制浏览器缓存相关的，让我们打开 react.js?v=432aac16 这个文件的请求头看一看：")]),t._v(" "),a("p",[t._v("果不其然，Cache-Control 属性被写为了： max-age=31536000,immutable ，将这个文件设置为了永久的强制缓存，也就是永远从本地取文件，然后通过向文件名中添加 hash 值控制版本更新。这样一来将依赖文件的缓存判断交给了浏览器老大哥，减少了 Vite 端的工作量，实在是妙啊。")]),t._v(" "),a("p",[t._v("在这一步 Vite 并不是只是简单的重写了一下路径。在服务启动的时候，vite 将会在所有源代码中检查类似 import { someMethod } from 'my-dep' 的裸模块导入语句，并执行以下操作")]),t._v(" "),a("ul",[a("li",[t._v("预构建")]),t._v(" "),a("li",[t._v("重写为合法的 URL")])]),t._v(" "),a("p",[t._v("其中「预构建」就是上文提到过的「提前编译文件」，在项目启动之初，Vite 会使用 esbuild 进行「依赖预构建」，有两个目的")]),t._v(" "),a("ol",[a("li",[t._v("CommonJS 和 UMD 兼容性")])]),t._v(" "),a("p",[t._v("在开发阶段中， Vite 的开发服务器将所有的代码都视为原生 ES 模块，所以需要在预构建阶段先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。")]),t._v(" "),a("ol",{attrs:{start:"2"}},[a("li",[t._v("优化加载性能")])]),t._v(" "),a("p",[t._v("Vite 将带有许多内部模块的 ESM 依赖转换为单个模块，以提高后续页面加载性能（降低请求数量），比如 lodash-es 有超过 600 个内置模块，一次性发送 600 多个 http 请求，就算是采用了 HTTP2 也是不可接受的，大量的网络请求在浏览器端会造成网络拥塞，导致页面的加载速度相当慢，通过预构建 lodash-es 成为一个模块，就只需要一个 HTTP 请求了！\n​")]),t._v(" "),a("p",[t._v("关于「依赖预构建」更多详细信息可以参考"),a("a",{attrs:{href:"https://cn.vitejs.dev/guide/dep-pre-bundling.html",target:"_blank",rel:"noopener noreferrer"}},[t._v("官方文档"),a("OutboundLink")],1)]),t._v(" "),a("p",[t._v("预构建完依赖项之后，再使用 es-module-lexer + magic-string 进行轻量级裸模块导入语句的重写。因为并没有进行完整的 AST 遍历，所以速度非常快，对于大多数文件来说这个时间都小于 1ms ！")])])}),[],!1,null,null,null);e.default=r.exports}}]);