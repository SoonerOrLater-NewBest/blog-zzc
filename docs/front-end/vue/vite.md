---
customLabelArray: [1, 3]
---

# <Label :level='1'/>Vite

[123](https://juejin.cn/post/6931618997251080200?content_source_url=https%3A%2F%2Fgithub.com%2Fvue3%2Fvue3-News)

### 天下苦 webpack 久矣

在前端这块混，肯定不能没有听说过 webpack，现代的大型前端应用一般都是用这玩意构建的，但是随着项目的增大，大家发现了 webpack 几个「难言之隐」

- 随着项目大小增长，项目冷启动时间指数增长
- 热更新时间也会随着项目大小增大而增长

所以才有了我们常戏称的：npm run dev ，然后去上个厕所，喝杯咖啡，回来可能还没跑完，极大的影响了开发效率。虽然 webpack 提供了很多方法去做构建优化，在日益庞大的前端项目中仍然不太够用，能不能有一种方式一劳永逸的解决这个问题呢？答案就是 Vite ！

### Vite 横空出世

vite 是如何解决这个世纪难题的呢，答案是  native ES modules。在浏览器没有原生模块化支持的时代，我们往往需要通过 webpack 等构建工具将整个项目打包成一个 js 文件，方便浏览器进行调用。但是随着浏览器厂商的不断努力，现代浏览器基本已经全部支持了 import/ export 语法，

### 为什么 Webpack 这么慢

在之前的浏览器中没有模块化的设计，所以期望把所有源代码编译进一个 js 文件中提供给浏览器使用，所以在开发中当我们运行启动命令的时候，webpack 总是需要从入口文件去索引整个项目的文件，编译成一个或多个单独的 js 文件，即使采用了代码拆分，也需要一次生成所有路由下的编译后文件（这也是为什么代码拆分对开发模式性能没有帮助）。这也导致了服务启动时间随着项目复杂度而指数增长

## Vite 是如何解决问题的

vite 是如何通过使用 native ES modules 优化服务启动时间的呢，使用 Vite 启动开发服务器的时候并不需要提前编译文件（其实是有一个类似过程的，下文详述），而是在浏览器请求对应 URL 的时候，再提供对应的文件，这就实现了在使用了路由懒加载的项目中，仅提供对应路由下的模块的编译文件，而没有索引全部代码的这一过程，项目启动时间始终为常量级。并不会随着项目复杂度变高而一直增长，我们来看看具体是怎么做的

### 依赖预构建

对 native ES modules 了解的同学可能会想到，它是不支持如下的裸模块导入的，那咋办

```js
import { someMethod } from 'my-dep';
```

经过 Vite 编译后的 src/main.tsx 文件,可以看到之前的 from 'react' 被重写为了 from "/node_modules/.vite/react.js?v=432aac16"

看起来 Vite 会将预构建的依赖缓存到 node_modules/.vite 路径下，可以看到文件名后跟着一串随机字符串，很容易就可以想到是用来控制浏览器缓存相关的，让我们打开 react.js?v=432aac16 这个文件的请求头看一看：

果不其然，Cache-Control 属性被写为了： max-age=31536000,immutable ，将这个文件设置为了永久的强制缓存，也就是永远从本地取文件，然后通过向文件名中添加 hash 值控制版本更新。这样一来将依赖文件的缓存判断交给了浏览器老大哥，减少了 Vite 端的工作量，实在是妙啊。

在这一步 Vite 并不是只是简单的重写了一下路径。在服务启动的时候，vite 将会在所有源代码中检查类似 import { someMethod } from 'my-dep' 的裸模块导入语句，并执行以下操作

- 预构建
- 重写为合法的 URL

其中「预构建」就是上文提到过的「提前编译文件」，在项目启动之初，Vite 会使用 esbuild 进行「依赖预构建」，有两个目的

1. CommonJS 和 UMD 兼容性

在开发阶段中， Vite 的开发服务器将所有的代码都视为原生 ES 模块，所以需要在预构建阶段先将作为 CommonJS 或 UMD 发布的依赖项转换为 ESM。

2.  优化加载性能

Vite 将带有许多内部模块的 ESM 依赖转换为单个模块，以提高后续页面加载性能（降低请求数量），比如 lodash-es 有超过 600 个内置模块，一次性发送 600 多个 http 请求，就算是采用了 HTTP2 也是不可接受的，大量的网络请求在浏览器端会造成网络拥塞，导致页面的加载速度相当慢，通过预构建 lodash-es 成为一个模块，就只需要一个 HTTP 请求了！
​

关于「依赖预构建」更多详细信息可以参考[官方文档](https://cn.vitejs.dev/guide/dep-pre-bundling.html)

预构建完依赖项之后，再使用 es-module-lexer + magic-string 进行轻量级裸模块导入语句的重写。因为并没有进行完整的 AST 遍历，所以速度非常快，对于大多数文件来说这个时间都小于 1ms ！
